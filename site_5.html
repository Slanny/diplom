<!DOCTYPE html>
<html lang = "ru">
<head>
<meta charset="UTF-8" />
<title>Методическое пособие микроконтроллера STM32</title>
<link href="templatemo_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <div id="templatemo_wrapper_outer">
    <div id="templatemo_wrapper_inner">
	
        <div id="templatemo_banner"></div> <!-- end of banner -->
    
        <div id="templatemo_menu">
	       <ul>
               <li><a href="index.html">Главная</a></li>
               <li><a href="theory.html">Теория</a></li>
               <li><a href="video.html">Видеоматериалы</a></li>
               <li><a href="lab.html">Лабораторные работы</a></li>
               <li><a href="tests.html">Тесты</a></li>
            </ul>
        </div> <!-- end of menu -->
    
        <div id="templatemo_content_wrapper">
    
    	   <div class="templatemo_side_bar margin_right_10">
               <div class="header_01">Категории</div>
               <ul>
                   <li><a href="main_info.html">Документация</a></li>
                    <li><a href="mcu.html">Микроконтроллер STM32</a></li>
                    <li><a href="arduino.html">Arduino</a></li>
                    <li><a href="ide.html">Настройка среды разработки STM32CubeIDE</a></li>
                    <li><a href="peripheral.html">Работа с переферийными устройствами</a></li>
                    <li><a href="clanguage.html">Программирование на языке Си</a></li>
                    <li><a href="info_site.html">О сайте</a></li>
                </ul>
		
                <div class="margin_bottom_20"></div>
            </div> <!-- end of left side bar -->
        
            <div class="templatemo_content margin_right_10">
                <div class="content_section">
                    <div class="header_01">Аппаратные прерывания и события.</div>
                    <p>
                        Аппаратное прерывание - это сигнал, сообщающий о каком-то событии. По его приходу выполнение программы приостанавливается, и управление переходит на функцию обработки прерывания (обработчик прерывания). После отработки функции управление возвращается в прерванный код программы.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        С точки зрения программы прерывание это вызов функции по внешнему, не связанному напрямую с программным кодом, событию.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        При определении понятия “прерывание” я употребил слово “событие” в общепринятом значении. Т.е. происшествие, нечто случившееся. Но в системе STM32 наряду с прерыванием (interrupt) существует еще одно строгое понятие – аппаратное событие (event).
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Событие – это нечто происшедшее с аппаратным узлом микроконтроллера. Например, переполнился таймер, в порт UART пришло данное, на внешнем входе изменился уровень сигнала и т.п.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Аппаратное событие – это то, что вызывает прерывание. Вернее может вызвать прерывание.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Без события прерывание невозможно. Именно аппаратное событие инициирует прерывание.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        События без прерываний могут происходить.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        И дело не только в том, что прерывания можно запретить и игнорировать события. В системе STM32 возможно использование событий для управления периферийными устройствами микроконтроллера. Например, прием байта портом UART вызывает событие, которое в свою очередь запускает контроллер прямого доступа к памяти (DMA) для пересылки этого байта в память. Получается, что происходит обработка события без прерывания программы.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Контроллер прерываний STM32.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Обработка и управление прерываниями производятся аппаратным узлом микроконтроллера – контроллером приоритетных векторных прерываний (NVIC). При возникновении разрешенного события контроллер прерывает выполнение программы, сохраняет в стеке необходимые данные и передает управление по адресу функции обработки прерывания. После выхода из функции-обработчика управление возвращается на адрес, по которому была прервана основная программа.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        С точки зрения программного управления контроллер прерывания не особо сложное устройство. Я бы выделил следующее.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Контроллер приоритетный. Т.е. обработка прерывания может быть прервана другим прерыванием с более высоким приоритетом. Прерывания с таким же или более низким приоритетом будут ожидать окончания обработки активного прерывания. Приоритеты можно разбивать на группы и подгруппы.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Как следствие предыдущего пункта для каждого прерывания может быть задан приоритет. Это число от 0 до 15. 0 – самый высокий приоритет. Для установки приоритетов существует специальный блок регистров. На каждое прерывание в нем отведен один байт.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Могут быть запрещены сразу все прерывания – глобальный запрет.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Могут быть запрещены или разрешены отдельные прерывания. Для этого существует регистр разрешения или маски прерываний. Его отдельные биты определяют разрешение для каждого прерывания.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Существует блок регистров ожидания обработки прерываний, каждый бит которых соответствует конкретному прерыванию и показывает, ожидает ли оно обработки. Биты регистров могут быть установлены, для принудительного перевода прерываний в состояние ожидания или сброшены для удаления.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Есть регистры действующих прерываний, которые показывают, находятся ли прерывания в стадии обработки.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Любое прерывание может быть вызвано программно. Для этого существует регистр программного вызова прерываний. Прерывание вызывается записью в него соответствующего номера.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Каждому из прерываний соответствует свой фиксированный адрес-вектор, по которому передается управление для обработки прерывания.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Формально обработкой и управлением прерываниями занимается контроллер прерываний. Но для возникновения прерывания необходимо выполнение нескольких условий связанных как с контроллером прерываний, так и с периферийными устройствами микроконтроллера. Поэтому будем рассматривать задачу в комплексе.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Программное управление прерываний STM32.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Для работы с аппаратными прерываниями необходимо:
                    </p>
                    <ul>
                        <li>Разрешить нужное прерывание в контроллере прерываний. Если необходимо, то задать для него приоритет.</li>
                        <li>Разрешить глобальные прерывания микроконтроллера.</li>
                        <li>Настроить устройство, в нашем случае таймер, на формирование запроса прерывания – события.</li>
                        <li>Создать функцию обработки прерывания.</li>
                    </ul>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Разрешение и запрет прерываний.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Для этого существуют функции библиотеки CMSIS.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        void NVIC_EnableIRQ(IRQn_Type IRQn) – разрешение прерывания с номером IRQn.

                    </p>
                    <p>
                        void NVIC_DisableIRQ(IRQn_Type IRQn) – запрет прерывания с номером IRQn.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        В файле stm32f103xb.h есть символьные имена, соответствующие номерам прерываний. Они описаны в структуре IRQn_Type. 
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="image_wrapper_01"><img src="images/site_5/pic_1_site_5.jpg" alt="image" width=450px></div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Команда разрешения прерывания перезагрузки таймера TIM1 будет выглядеть так.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        NVIC_EnableIRQ(TIM1_UP_IRQn);
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Установка проиритетов прерываний.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                       По состоянию сброса для всех прерываний устанавливается самый высокий приоритет (0). Для его изменения существует функция библиотеки CMSIS.     
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
                    </p>
                    <ul>
                        <li>IRQn – номер прерывания , можно в символьном виде типа IRQn_Type;</li>
                        <li>priority – приоритет (0 … 15), 0 – наивысший.</li>
                    </ul>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Например, если мы хотим для таймера TIM1 установить самый низкий приоритет, то необходимо выполнить команду.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        NVIC_SetPriority(TIM1_UP_IRQn, 15);
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Глобальные разрешения и запрет прерываний.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        В программе бывают отрезки, которые недопустимо прерывать по самым разным соображениям. А аппаратные прерывания совершенно непредсказуемы. В этом случае можно запретить все прерывания, используя функцию глобального  запрета.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        __disable_irq (); // запретить прерывания
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        По окончанию непрерываемого блока надо разрешить прерывания специальной функцией.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        __enable_irq ();  // разрешить прерывания
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Настройка устройства на формирование события и прерывания.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Это действие касается настройки конкретного периферийного устройства и индивидуально для каждого из них. Будем рассматривать для каждого устройства отдельно. В следующем уроке настроим таймер.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="header_02">Функции обработки прерываний STM32.</div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        В предыдущих уроках мы уже использовали функцию обработки прерывания таймера. Она была создана конфигуратором STM32CubeMX. Сейчас разберемся, откуда она появилась.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        В микроконтроллерах STM32 поддерживается до 68 аппаратных прерываний. Каждому из них соответствует свой адрес – вектор. По этому адресу передается управление программы при возникновении прерывания.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Конкретные адреса для каждого источника можно посмотреть в документации на микроконтроллер. Выглядит это примерно так.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <div class="image_wrapper_01"><img src="images/site_5/pic_2_site_5.png" alt="image" width=450px></div>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Из таблицы видно, что наш таймер TIM1 при перезагрузке формирует прерывания по адресу 00A4.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        В файле startup\startup_stm32f103xb.s таблица векторов преобразуется в символьные имена функций обработки прерываний.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        .word TIM1_BRK_IRQHandler
                    </p>
                    <p>
                        .word TIM1_UP_IRQHandler
                    </p>
                    <p>
                        .word TIM1_TRG_COM_IRQHandler
                    </p>
                    <p>
                        .word TIM1_CC_IRQHandler
                    </p>
                    <p>
                        .word TIM2_IRQHandler
                    </p>
                    <p>
                        .word TIM3_IRQHandler
                    </p>
                    <p>
                        .word TIM4_IRQHandler
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Для нашего таймера это TIM1_UP_IRQHandler.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Необходимо создать функцию с таким именем и разместить в ее теле обработчик прерывания.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        void TIM1_UP_IRQHandler(void) {
                    </p>
                    <p>
                            // код обработки прерывания
                    </p>
                    <p>
                            // код или функция завершения прерывания
                    </p>
                    <p>
                        }
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        В начале файла c/cpp или h надо объявить функцию, разместить прототип.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        void TIM1_UP_IRQHandler(void);
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        При выходе из функции, еще необходимо выполнить определенные действия для завершения прерывания. Как правило, это сброс флага прерывания.
                    </p>
                    <div class="margin_bottom_10"></div>
                    <p>
                        Иначе может произойти следующее. Устройство сформировало событие. Как следствие стал активным флаг прерывания. Произошло, и было обработано прерывание. Программа вернулась к месту, на котором была прервана. А флаг прерывания остался активным. Произойдет новое прерывание, вызванное ошибкой алгоритма. Перед возвратом надо сбросить флаг. Об этом подробно в следующем уроке.
                    </p>
                    <div class="margin_bottom_20"></div>
                    <p>
                    Автор: Эдуард
                </p>
                <div class="margin_bottom_10"></div>
                </div>
            </div> <!-- end of content -->
        
            <div class="templatemo_side_bar">	
                <div class="header_01">Микроконтроллер STM32</div>
            
                <div class="right_bar border_bottom">
                    <p>
                        Одна из линеек микроконтроллеров, которые производит компания STMicroelectronics.
                    </p>
                </div>
                        
                <div class="margin_bottom_10"></div>
            
                <div class="right_bar">
                    <div class="header_01">Применяемость</div>
                    <p>
                        Создана для широкого спектра применений, и применяются в различных областях, включая автоматизацию домашней электроники, транспортные средства, медицинские устройства, устройства IoT, промышленные автоматизированные системы и различные приборы и устройства.
                    </p>
                </div>
    
                <div class="margin_bottom_10"></div>
                
            </div> <!-- end of right side bar -->
    	
            <div class="cleaner"></div>    
        </div> <!-- end of content wrapper -->
    
    </div>
    </div>

<div id="templatemo_footer">
    <a href="#">alsou2070@gmail.com<br></a>
    <a href="#">© 2023 Все права защищены</a>
</div> <!-- end of footer -->
    
    <div class="margin_bottom_10"></div>
    
    <div class="content_section">
		<div class="margin_bottom_10"></div>
	</div>
</body>
</html>